// ======================================================================
// This file is autogenerated - Please do not edit
// ======================================================================

/* tslint:disable:no-unused-variable */

import request from "request-promise";

{{#models}}{{#model}}
{{#description}}
/**
* {{{description}}}
*/
{{/description}}
export interface {{classname}} {{#parent}}extends {{{parent}}} {{/parent}}{
{{#vars}}
{{#description}}
    /**
    * {{{description}}}
    */
{{/description}}
    {{name}}: {{#isEnum}}{{classname}}.{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{datatype}}}{{/isEnum}};
{{/vars}}
}

{{#hasEnums}}
export namespace {{classname}} {
{{#vars}}
{{#isEnum}}
    export enum {{datatypeWithEnum}} {
{{#allowableValues}}{{#values}}
        {{.}} = <any> "{{.}}",{{/values}}{{/allowableValues}}
    }
{{/isEnum}}
{{/vars}}
}
{{/hasEnums}}
{{/model}}{{/models}}

export interface ApiResult<T> {
    status: number;
    body: T;
    headers: {};
}

export interface ApiError {
    message: string;
    code: string;
}

{{#apiInfo}}{{#apis}}export class {{classname}} {
    private basePath = process.env.GATEWAY_PRIVATE + "/v4/";
    private defaultHeaders: any = {
        "accept": "application/json",
        "content-type": "application/json"
    };

{{#operations}}{{#operation}}
    /**
     *{{#summary}} {{summary}}{{/summary}}
     {{#allParams}}* @param {{paramName}}{{#description}} {{description}}{{/description}}
     {{/allParams}}*/
    public async {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}{{#hasMore}}, {{/hasMore}}{{/allParams}}): Promise<ApiResult<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}any{{/returnType}}>> {
        const path = this.basePath + "{{path}}"{{#pathParams}}
            .replace("{" + "{{baseName}}" + "}", String({{paramName}})){{/pathParams}};
        let queryParameters: any = {};
        let headerParams: any = combine({}, this.defaultHeaders);
        let formParams: any = {};

{{#allParams}}{{#required}}
        // verify required parameter "{{paramName}}" is set
        if (!{{paramName}}) {
            throw new Error("Missing required parameter {{paramName}} when calling {{nickname}}");
        }
{{/required}}{{/allParams}}
{{#queryParams}}
        if ({{paramName}} !== undefined) {
            queryParameters["{{baseName}}"] = {{paramName}};
        }

{{/queryParams}}
{{#headerParams}}
        headerParams["{{baseName}}"] = {{paramName}};

{{/headerParams}}
        let useFormData = false;

{{#formParams}}
        if ({{paramName}} !== undefined) {
            formParams["{{baseName}}"] = {{paramName}};
        }
{{#isFile}}
        useFormData = true;
{{/isFile}}

{{/formParams}}
        const requestOptions: request.Options = {
{{#bodyParam}}
            body: {{paramName}},
{{/bodyParam}}
            method: "{{httpMethod}}",
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            resolveWithFullResponse: true,
            simple: false
        };

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        const response = await request(requestOptions);

        // Handle 200 status codes
        if ((response.statusCode < 300) && (response.statusCode >= 200)) {
            const apiResult: ApiResult<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}any{{/returnType}}> = {
                body: response.body,
                status: response.statusCode,
                headers: response.headers
            };

            // We cannot return 'request' because it uses Bluebird
            // under the hood, instead of native Promises
            return Promise.resolve(apiResult);
        }

        const apiError: ApiError = {
            message: response.body.error,
            code: response.body.code
        };

        return Promise.reject(apiError);
    }{{/operation}}{{/operations}}
}{{/apis}}{{/apiInfo}}

/**
* Combines two objects of different types.
*/
function combine<T, U>(first: T, second: U): T & U {
    for (let key in second) {
        if (second.hasOwnProperty(key)) {
            (<any>first)[key] = second[key];
        }
    }

    return <T & U>first;
}