//
// DO NOT MODIFY - GENERATED FILE
//

const request = require('request-promise');
const Cookie = require('tough-cookie').Cookie;

class Client {
  constructor(url) {

    // Trim trailing slash if necessary
    if (url.substring(url.length - 1, url.length) == '/') {
      url = url.substring(0, url.length - 1);
    }

    this.url = url;
    this.session = null;
    this.delay = 0;
  }
  {{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}
  /*
   * {{summary}}
   * {{notes}}
{{#allParams}}   * @param {{=<% %>=}}{<% dataType %>} <%={{ }}=%> {{paramName}} {{description}}
{{/allParams}}   * @return Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}void{{/returnType}}>
   */
  {{nickname}}({{#allParams}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) {
    {{#allParams}}{{#required}}if ({{paramName}} == null) 
      throw new ClientError("Missing required parameter '{{paramName}}' when calling {{nickname}}");
    {{/required}}{{/allParams}}
    // Get fully qualified path
    let path = this.url + replaceAll("{{{path}}}", "\\{format\\}", "json");
    {{#pathParams}}
    path = replaceAll(path, "\\{" + "{{baseName}}" + "\\}", encodeURIComponent({{{paramName}}}.toString()));
    {{/pathParams}}
    const queryParams = {};
    {{#queryParams}}
    // Set query parameter "{{baseName}}" to "{{paramName}}"
    if ({{paramName}} !== undefined) queryParams.{{baseName}} = {{paramName}};
    {{/queryParams}}
    // Create query string from params
    path += createQueryString(queryParams);

    const headers = {};

    // Set default headers
    headers["Content-Type"] = "application/json";
    headers["Accept"] = "application/json";

    {{#headerParams}}
    // Set header "{{baseName}}" to "{{paramName}}"
    if ({{paramName}} != null) headers["{{baseName}}"] = {{paramName}};
    {{/headerParams}}
    // Get request-promise module options from params, with defaults
    const options = getRequestOptions(headers, {{#bodyParam}}{{^isBinary}}{{paramName}}{{/isBinary}}{{#isBinary}}null{{/isBinary}}{{/bodyParam}}{{^bodyParam}}null{{/bodyParam}}, "{{httpMethod}}", path);

    // Set authorization headers
    if (this.session && this.session.cookies) options.jar = this.session.cookies;

    return new Promise((resolve, reject) => {
      // Delay the request if necessary
      setTimeout(() => {
        request(options)
        .then(res => {
          // Update the session if necessary
          if ("{{{path}}}" === "/cb/sessions" || "{{{path}}}" === "/cb/users") this.updateSession(res, "{{httpMethod}}");
          // Reset delay back to zero
          this.delay = 0;
          resolve(res);
        });
      }, this.delay);
    });
  }
  {{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}

  /*
   * Routes /cb/sessions response to appropriate handler
   * based on HTTP method.
   */
  updateSession(res, method) {
    switch(method) {
      case "POST":
        const okStatus = /^2\d{2}$/;
        if (okStatus.test(res.statusCode)) this.setSession(res);
        break;
      case "DELETE":
        this.clearSession();
        break;
      default:
        return;
    }
  }

  /*
   * Sets the session property from a POST /cb/sessions response.
   */
  setSession(res) {
    this.session = {
      cookies: this.getCookies(res),
      user: this.getUser(res)
    };
  }

  /*
   * Unsets the session property.
   */
  clearSession() {
    this.session = null;
  }

  /*
   * Gets user from a POST /cb/sessions response.
   */
  getUser(res) {
    if (res && res.body && res.body.user) {
      return res.body.user;
    } else if (res && res.body) {
      return res.body;
    } else {
      throw new ClientError("Could not update session due to malformed response body.");
    }
  }

  /*
   * Gets cookies from a POST /cb/sessions response.
   */
  getCookies(res) {
    if (!(res && res.headers && res.headers['set-cookie']))
      throw new ClientError("Could not update session due to missing set-cookie header.");
    const cookies = res.headers['set-cookie'].map(Cookie.parse);
    const jar = request.jar();
    cookies.forEach(cookie => {
      jar.setCookie(cookie, this.url);
    });
    return jar;
  }

  wait(ms) {
    if (!Number.isInteger(ms)) throw new ClientError('Delay param must be an integer.');
    this.delay = ms;
  }
}

function replaceAll(haystack, needle, replace) {
  let result = haystack;
  if (needle != null && replace != null) {
    result = haystack.replace(new RegExp(needle, 'g'), replace);
  }
  return result;
}

function createQueryString(queryParams) {
  let queryString ='';
  let i = 0;
  for (let queryParamName in queryParams) {
    if (i == 0) {
      queryString += '?' ;
    } else {
      queryString += '&' ;
    }
    queryString +=  queryParamName + '=' + encodeURIComponent(queryParams[queryParamName]);
    i++;
  }
  return queryString;
}

function getRequestOptions(headers, body, method, path) {
  return {
    // Config for request-promise module
    json: true,
    resolveWithFullResponse: true,
    simple: false,
    timeout: 10000,
    // Request details
    uri: path,
    method: method,
    headers: headers,
    body: body
  };
}

class ClientError extends Error {
  constructor(message, status) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
  }
}

module.exports = Client;
